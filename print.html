<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./introduction.html"><strong>1.</strong> Introduction</a></li><li><a href="./build_basics.html"><strong>2.</strong> Build Basics</a></li><li><a href="./build_config.html"><strong>3.</strong> Build Configuration</a></li><li><a href="./layers.html"><strong>4.</strong> Layers</a></li><li><a href="./minimal_image.html"><strong>5.</strong> Creating a minimal image</a></li><li><a href="./command_cheat_sheet.html"><strong>6.</strong> Command Cheat Sheet</a></li><li><a href="./conf_cheat_sheet.html"><strong>7.</strong> Conf Cheat Sheet</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <p>poky is the build system for yocto</p>
<p><strong>poky = bitbake + open embedded core</strong></p>
<p>poky builds following components</p>
<ol>
<li>
<p>bootloader image</p>
</li>
<li>
<p>linux kernel image</p>
</li>
<li>
<p>root fs image</p>
</li>
<li>
<p>toolchais and SDKs for application development</p>
</li>
</ol>
<ul>
<li>1 + 2 + 3 =&gt; system development</li>
<li>4         =&gt; for application development</li>
</ul>
<p>Openwrt took buildroot approach of makefiles + kconfig while openembedded took a different approach</p>
<p>OpenEmbedded recipes can specify dependencies between packages, and later on, <strong>BitBake parses all the recipes and creates a queue of tasks in the correct order to fulfill the dependencies</strong></p>
<p>Two examples of distributions created with OpenEmbedded are Angstrom and OpenMoko. Another OpenEmbedded-based distribution was Poky</p>
<h3>UBUNTU 15.10 SETUP</h3>
<hr />
<pre><code>sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat libsdl1.2-dev xterm make xsltproc docbook-utils fop dblatex xmlto autoconf automake libtool libglib2.0-dev python-gtk2 bsdmainutils screen
</code></pre>
<p>poky incorporates stable bitbake release. So to get started with yocto, we just need to get poky</p>
<pre><code>sudo install -o $(id -u) -g $(id -g) -d /opt/yocto 
$ cd /opt/yocto 
$ git clone --branch jethro --single-branch git://git.yoctoproject.org/poky
</code></pre>
<h6>NOTE:</h6>
<p>If you face compilation errors w.r.t qemu-native due to dbus incompatibility (<code>poky/qemuarm/tmp/work/x86_64-linux/qemu-native/2.4.0-r1/build/config.log</code>), Apply <a href="http://lists.openembedded.org/pipermail/openembedded-core/2015-November/112207.html">this patch</a></p>
<p>The <strong>Poky build system</strong> supports virtualized QEMU machines for the following architectures:</p>
<ul>
<li>ARM (qemuarm)</li>
<li>x86 (qemux86)</li>
<li>x86-64 (qemux86-64)</li>
<li>PowerPC (qemuppc)</li>
<li>MIPS (qemumips, qemumips64)</li>
</ul>
<p>Poky also supports some reference hardware Board Support Packages (BSPs), representative of the architectures just listed. These are those BSPs</p>
<ul>
<li>Texas Instruments Beaglebone (beaglebone)</li>
<li>Freescale MPC8315E-RDB (mpc8315e-rdb)</li>
<li>Intel x86 based PCs and devices (genericx86 and genericx86-64)</li>
<li>Ubiquiti Networks EdgeRouter Lite (edgerouter)</li>
</ul>
<h3>ORGANIZING BUILD DIR</h3>
<hr />
<p>There is no right way to structure the build directories when you have multiple projects, but a good practice is to have <strong>one build directory per architecture or machine type</strong>.</p>
<p>They can all share a <strong>common downloads</strong> folders, and even a shared state cache (this will be covered later on), so keeping them separate won't affect the build performance, but it will allow you to develop on multiple hardware projects simultaneously</p>
<pre><code>$ cd /opt/yocto/poky  
$ source oe-init-build-env &lt;build dir&gt; --&gt; Create a build envoronment in your current shell
</code></pre>
<h5>TIP</h5>
<p>BitBake is designed with a client/server abstraction, so we can also start a memory resident server and connect a client to it. With this setup, loading cache and configuration information each time is avoided, which saves some overhead. To run a memory resident BitBake that will always be available, you can use the oe-init-build-env-memres script as follows</p>
<pre><code>source oe-init-build-env-memres 12345 qemuarm
</code></pre>
<p>You can then kill the memory resident BitBake by executing the following command</p>
<pre><code>$ bitbake -m
</code></pre>
<p><strong>NOTE</strong>: Don't use memres and normal setup at the same time as it could lead to confusing errors</p>
<h3>HOW BUILD WORKS</h3>
<hr />
<p><code>oe-init-build</code> script calls the <code>scripts/oe-setup-builddir</code> script inside the poky directory to create the build directory.</p>
<p>On creation, the build directory contains a conf directory with the following three files:</p>
<ul>
<li><strong>bblayers.conf</strong>: This file lists the metadata layers to be considered for this project.</li>
<li><strong>local.conf</strong>: This file contains the project-specific configuration variables. You can set common configuration variables to different projects with a site.conf file, but this is not created by default.</li>
<li><strong>templateconf.cfg</strong>: This file contains the directory that includes the template configuration files used to create the project. By default it uses the one pointed to by the templateconf file in your Poky installation directory, which is meta-yocto/conf by default</li>
</ul>
<p>Removing these will start the build from scratch</p>
<pre><code>$ cd /opt/yocto/poky/&lt;build dir&gt;
$ rm -Rf tmp sstate-cache
</code></pre>
<h5>CHOOSING A CUSTOM TEMPLATE CONFIGURATION</h5>
<p>when you create your build directory using the <code>TEMPLATECONF</code> variable; for example</p>
<pre><code>$ TEMPLATECONF=meta-custom/config source oe-init-build-env &lt;build- dir&gt; 
</code></pre>
<p>The <code>TEMPLATECONF</code> variable needs to refer to a directory containing templates for both local.conf and bblayer.conf, but named local.conf.sample and bblayers.conf.sample</p>
<h3>BUILD CONFIG</h3>
<hr />
<p>Choose the image that you want to build for. Poky has support for some <strong>image configurations</strong> by default</p>
<pre><code>$ cd /opt/yocto/poky 
$ ls meta*/recipes*/images/*.bb
</code></pre>
<h5>DIFFERENT IMAGE CONFIG SUFFIXES</h5>
<ul>
<li><strong>dev</strong>: These images are suitable for development work, as they contain headers and libraries.</li>
<li><strong>sdk</strong>: These images include a complete SDK that can be used for development on the target</li>
<li><strong>initramfs</strong>: This is an image that can be used for a RAM-based root filesystem, which can optionally be embedded with the Linux kernel</li>
</ul>
<h3>STARTING THE BUILD</h3>
<hr />
<pre><code>$ cd /opt/yocto/poky
$ source oe-init-build-env qemuarm
$ MACHINE=qemuarm bitbake core-image-minimal
</code></pre>
<h3>HOW IT WORKS</h3>
<hr />
<p>When you pass a target recipe (<strong>core-image-minimal.bb</strong>) to BitBake, it first parses the following configuration files:</p>
<ul>
<li><strong><build dir>/conf/bblayers.conf</strong>: This file is used to find all the configured layers</li>
<li><strong>meta/conf/layer.conf</strong>: This file is used on each configured layer</li>
<li><strong>meta/conf/bitbake.conf</strong>: This file is used for its own configuration</li>
<li><strong><build dir>/conf/local.conf</strong>: This file is used for any other configuration the user may have for the current build</li>
<li><strong>meta/conf/machine/<machine>.conf</strong>: This file is the machine configuration; in our case, this is <code>qemuarm.conf</code></li>
<li><strong>meta-yocto/conf/distro/<distro>.conf</strong>: This file is the distribution policy; by default, this is the <code>poky.conf</code> file</li>
</ul>
<p>And then BitBake parses the <strong>target recipe</strong> that has been provided and its dependencies. The outcome is a set of interdependent tasks that BitBake will then execute in order</p>
<h5>TIP 1</h5>
<p>Most developers won't be interested in keeping the whole build output for every package, so it is recommended to configure your project to remove it with the following configuration in your <code>conf/local.conf</code> file:</p>
<pre><code>INHERIT += &quot;rm_work&quot; 
</code></pre>
<p>But at the same time, configuring it for all packages means that you won't be able to develop or debug them. You can add a list of packages to exclude from cleaning by adding them to the <code>RM_WORK_EXCLUDE</code> variable. For example, if you are going to do BSP work, a good setting might be:</p>
<pre><code>RM_WORK_EXCLUDE += &quot;linux-yocto u-boot&quot;
</code></pre>
<h5>TIP 2</h5>
<p>You can use a <code>custom template</code> config <code>local.conf.sample</code> configuration file in your own layer to keep these configurations and apply them for all projects so that they can be shared across all developers. Use the <code>TEMPLATECONF</code> var</p>
<h3>IMAGES</h3>
<hr />
<p>You can find images here</p>
<pre><code>tmp/deploy/images/qemuarm
</code></pre>
<p>directory inside your build directory</p>
<h5>TIP</h5>
<p>By default, images are not erased from the deploy directory, but you can configure your project to remove the previously built version of the same image by adding the following to your <code>conf/local.conf</code> file:</p>
<pre><code>RM_OLD_IMAGE = &quot;1&quot;
</code></pre>
<h3>RUN THE IMAGE</h3>
<hr />
<pre><code>$ runqemu qemuarm core-image-minimal
</code></pre>
<p>Poky contains three metadata directories, meta, meta-yocto, and meta-yocto-bsp, as well as a template metadata layer, meta-skeleton, that can be used as a base for new layers</p>
<ul>
<li><strong>meta</strong>: This directory contains the OpenEmbedded-Core metadata, which supports the ARM, x86, x86-64, PowerPC, MIPS, and MIPS64 architectures and the QEMU emulated hardware.</li>
<li><strong>meta-yocto</strong>: This contains Poky's distribution-specific metadata.</li>
<li><strong>meta-yocto-bsp</strong>: This contains metadata for the reference hardware boards</li>
</ul>
<h4>USING SYSTEMD AS INIT SYSTEM INSTEAD OF INIT</h4>
<hr />
<ul>
<li>Copy these lines in your conf/local.conf</li>
</ul>
<pre><code>DISTRO_FEATURES_append = &quot; systemd&quot;
VIRTUAL-RUNTIME_init_manager = &quot;systemd&quot;
DISTRO_FEATURES_BACKFILL_CONSIDERED = &quot;sysvinit&quot;
VIRTUAL-RUNTIME_initscripts = &quot;&quot;
</code></pre>
<p><strong>NOTE</strong>: Don't miss the space in  <code>DISTRO_FEATURES_append</code></p>
<p><strong>NOTE</strong>: Remove <code>tmp</code> folder incase you already have a built image</p>
<h5>CLEAN A RECIPE</h5>
<hr />
<p><strong>bitbake -c clean <recipe></strong></p>
<h5>FIND AND CHECK PACKAGE CONTENT</h5>
<hr />
<p>search here --&gt; <strong>cd tmp/deploy/rpm/</strong></p>
<p>&amp;</p>
<p>rpm -qlp &lt;package_name&gt;.rpm</p>
<p><strong>NOTE</strong>: Make sure that you added <code>IMAGE_INSTALL_append = &quot;&lt;recipe name&gt;&quot;</code> for package contents to be present in target image rootfs</p>
<h5>SEARCH BITBAKE ENV</h5>
<hr />
<p><strong>bitbake -e mosquitto | grep ^S=</strong>      --&gt; find src dir of a recipe's package</p>
<p><strong>bitbake -e mosquitto | grep ^WORKDIR</strong> --&gt; find working dir of a package</p>
<p><strong>bitbake -c devshell mosquitto</strong>        --&gt; open dev shell of a recipe</p>
<p>upacks source, patches it and opens recipe dir with environmet correctly set</p>
<p><strong>bitbake -c listtasks mosquitto</strong>       --&gt; list all the tasks of a recipe***</p>
<p><strong>bitbake -c compile -f mosquitto</strong>      --&gt; force compile</p>
<p><strong>bitbake --show-versions | grep mosquitto</strong> --&gt; show package version</p>
<p><strong>bitbake -gu depexp mosquitto</strong>         --&gt; show dependencies</p>
<h4>conf/local.conf (or) local.conf.sample in your own layer</h4>
<hr />
<h6>Enabling Build History</h6>
<p>If you enable build history, yocto will save the build history of packages in a local git repository allowing you to compare the changes you did to a package.</p>
<pre><code>INHERIT += &quot;buildhistory&quot;
BUILDHISTORY_COMMIT = &quot;1&quot;
</code></pre>
<h6>Removing Build Output</h6>
<ul>
<li>Removing whole build output</li>
</ul>
<pre><code>INHERIT += &quot;rm_work&quot;
</code></pre>
<ul>
<li>Removing specific packages</li>
</ul>
<pre><code>RM_WORK_EXCLUDE += &quot;linux-yocto u-boot&quot;
</code></pre>
<ul>
<li>By default previous images are not erased. To erase previous images</li>
</ul>
<pre><code>RM_OLD_IMAGE = &quot;1&quot;
</code></pre>
<h6>Changing BBAPPEND As Warning Instead of Error</h6>
<p><code>BB_DANGLINGAPPENDS_WARNONLY = &quot;true&quot;</code></p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
